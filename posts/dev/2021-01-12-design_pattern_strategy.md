
[**Head First Design Patterns**](https://www.hanbit.co.kr/store/books/look.php?p_code=B9860513241) 책을 보고 정리한 내용입니다. 디자인 패턴을 처음 입문하시는 분들께 추천드리고픈 책입니다.

# 들어가면서...
---
## 디자인패턴을 왜 배워야 할까?
똑같은 객체지향 프로그래밍을 하면서도, 내가 하는 프로그래밍과 고수들이 하는 프로그래밍은 뼈대가 다르다. 똑같은 요구사항을 받아도, 초수의 코드는 변경이 어렵고 하나를 고치려면 열을 더 고쳐야 하지만, 고수는 기존의 코드를 거의 변경하지 않고도 새로운 기능을 추가하곤 한다.

초수가 어떻게 하면 고수가 될 수 있을까? 연차를 쌓는 것만이 답일까?

최고의 전략가 이순신 장군은 손자병법을 달고 사셨다. 다양한 전투상황에 대비하기 위해, 선대 전략가들의 병법서들을 숙지한 것이다. 다행히도, 객체지향 프로그래머들에게도 선배들로부터 내려지는 **병법서**가 있다!

그것이 바로 **디자인패턴**이다.

지금 내가 고민하는 이 문제는, 이미 십여년 전에 선배 개발자분들도 직면했던 문제다. 그것만으로도 디자인패턴을 공부해야하는 이유가 충분하다. 선배 개발자들이 직면했던 문제와, 해결하기 위한 지혜들을 디자인패턴을 통해 습득할 수 있다.

Head First Design Patterns 책이 다른 디자인패턴 책들과 다른점은, 이해하기 쉬운 예제로 문제상황부터 해결방법까지 마치 고사성어 풀이하듯 설명한다는 점이다. 나처럼 디자인패턴을 처음 접하는 초보자들에게 추천하고 싶다. 

>
1. 스트래티지 패턴
2. 옵저버 패턴
3. 데코레이터 패턴
4. 팩토리 패턴
5. 싱글턴 패턴
6. 커맨드 패턴
7. 어댑터 패턴 & 퍼사드 패턴
8. 템플릿 메소드 패턴
9. 이터레이터와 컴포지트 패턴
10. 스테이트 패턴
11. 프록시 패턴
12. 컴파운드 패턴

이 책에서 소개하는 패턴들을 벨로그에 정리할 예정이다. 패턴소개에 중점을 두기 때문에, 코드를 상세하게 적진 않을 것이다. 참고로 벨로그 글은 한국버전(?)으로 각색이 들어가서 원서와 조금 다를 수 있다. 먼저 첫번째 주제는 **스트래이티지 패턴**이다.


# 1. 스트래티지 패턴
---
## # 문제는 '우아한 오리들' 애플리케이션에서 시작됐다.

![](https://images.velog.io/images/hanna2100/post/68949c97-e99b-4283-8e94-9494a40b6f16/20210112_004207.png)

명수는 연못에 오리를 키우는 '우아한 오리들' 이라는 게임회사를 다니고 있다. 이 게임에서는 헤엄도 치고 꽥꽥거리는 다양한 오리들이 존재한다. 이 게임을 처음 만든 사람들은 객체지향 기법에 따라, `Duck` 이라는 수퍼클래스를 만들고 그 클래스를 확장하여 다른 오리클래스들을 만들었다.

**수퍼클래스 Duck**
```java
class Duck {
	quack() { "꽥꽥" } < 꽥꽥과 수영은 모든 오리들이 하므로 수퍼클래스에 미리 구현함
	swim() { "수영하기" }
	display() < 모양은 서로 다르기 때문에 추상메소드
 }
```
**하위클래스 MallardDuck, RedheadDuck**
```java
class MallardDuck extends Duck {
	display() // 청둥오리 모양새
}

class RedHeadDuck extends Duck {
	display() // 홍머리오리 모양새
}
```

그런데, 게임업계 경쟁이 치열해지면서 획기적인 변화가 필요하게 되었다. 오리들은 더이상 꽥꽥거리거나 수영만 하지 않는다.

> **앞으로 오리가 날도록 해야한다!**

### 1. 상속은 올바른 해결책이 아니다.

![](https://images.velog.io/images/hanna2100/post/9f14b87f-2cb6-4079-950f-c1f3871577b5/jjv1oh.jpg)

새로운 요구사항이 언짢은 명수는 `Duck`클래스에 `fly()`메소드만 추가하면 모든 오리들이 날 수 있을거라 생각했다. 상속은 이럴때 쓰는거지!

**`fly()`가 추가된 수퍼클래스 Duck**
```java
class Duck {
	quack() { "꽥꽥" } 
	swim() { "수영하기" }
	display()
	fly() { "훨훨 날기" } < 추가
 }
```
> [ 시스템 ] Duck 클래스에 `fly()` 가 추가되었습니다!
[ 시스템 ] Duck을 상속한 모든 오리클래스들에게 `fly()` 기능이 부여됩니다! 

그런데..! 이렇게 코드를 수정한 명수는 사장님께 불려가게 된다.

![](https://images.velog.io/images/hanna2100/post/6d27ea95-ca33-4c41-9c52-dc34517a5a3d/%EB%AC%B4%ED%95%9C%EB%8F%84%EC%A0%84%EC%A7%A4_%EB%B0%95%EB%AA%85%EC%88%98_(28).jpg)

> "아니 이봐요 명수씨! 도대체 패치를 어떻게 했길래 **고무오리**들이 날아다니게 된겁니까?! 예?!!"

그렇다. 수퍼클래스에 `fly()` 메소드를 추가하자, `fly()` 기능이 필요 없는 다른 클래스들까지 해당 메소드가 생기고 말았다. 상속을 아주 잘 활용하였다고 생각했지만, 실제로는 버그를 생산하는데 일조한 것이다.

![](https://images.velog.io/images/hanna2100/post/75f794e3-f0aa-4e0f-9a03-8518a123dacc/m_20190126014619_kkfgcuru.png)

> 그러면... 고무오리만 `fly()` 메소드를 오버라이드 해버리지 뭐....

**RubberDuck 클래스**
```java
class RubberDuck extends Duck {
	quack() { "삑삑" } // 삑삑 소리가 나게 오버라이드 
	fly() {  } < 아무것도 하지 않도록 오버라이드
	display() // 고무오리 모양새
 }
```

과연 이것이 Best Practice일까? 앞으로 **나무오리**가 생긴다면, `quack()` 도 `fly()` 도 아무것도 하지 않도록 오버라이드 해야한다.
앞으로 새로운 오리들이 계속해서 생겨날 텐데, 그렇게 되면 서브클래스마다 상속받는 메소드들을 일일히 검토해야한다. 결국 전체가 아닌 일부 오리만 날거나 꽥꽥거릴 수 있도록하는 깔끔한 방법을 찾아야한다.


### 2. 인터페이스가 해결책이 될 수 있을까?

그렇다면 수퍼클래스 Duck에서 `fly()` 기능을 삭제하는 대신, Flyable 인터페이스에 `fly()`를 만들고, 날 수 있는 오리들만 Flyable 인터페이스를 구현하는 건 어떨까?
모든 오리들이 소리를 내지 않을 수도 있으니, Quackable 인터페이스를 만드는 것도 좋겠다!

**수퍼클래스 Duck**
```java
class Duck {
	swim()
	display()
 }
```
**인터페이스 for Duck**
```java
interface Flyable {
	fly()
 }
 
interface Quackable {
	quack()
 }
```
**하위클래스 MallardDuck, RubberDuck, WoodDuck**
```java
class MallardDuck extends Duck implements Flayable, Quackable {
	display()
	fly()
	quack()
 }
 
class RubberDuck extends Duck implements Quackable {
	display()
	quack()
 }
 
 class WoodDuck extends Duck {
 	display()
 }
```

![](https://images.velog.io/images/hanna2100/post/bff9ee00-342d-49be-88a0-1c9ab9be9bf9/20180829_5b857ea30d025.jpg)

이렇게 구현하는 건 정말 바보같은 짓이다. 날지 않는 오리들의 `fly()`메소드를 오버라이드 하지 않으려고 날 수 있는 오리들에게 `fly()`메소드를 구현해줘야하는 일이 생겨버렸다.
또한, `fly() { "훨훨 날다" }` 라고 날 수 있는 하위클래스들에게 똑같은 메소드를 복붙해야하는 일이 생긴다. 즉, 코드를 재사용 할 수 없다는 것이다.

상속도 답이 아니고, 인터페이스도 처음엔 괜찮아 보였지만, 인터페이스에는 구현된 코드가 전혀 들어 갈 수 없다는 점에서 재사용성에 대한 문제가 있음을 깨달았다.

## # 달라지는 부분을 분리해라! 일명 캡슐화 원칙.

> 디자인원칙 1.
애플리케이션에서 달라지는 부분을 찾아내고, 달라지지 않는 부분으로부터 분리시킨다.

하나의 모델에 불변하는 부분과 바뀌는 부분이 나뉘어져 있다면, 바뀌는 부분을 따로 뽑아 정의한다. 그러면 바뀌지 않는 부분에 영향을 주지 않고, 바뀌는 부분만 컨트롤 할 수 있게 된다. 이것이 캡슐화이다.

### 그렇다면 어떻게 분리해야 할까?
Duck 클래스의 경우 `fly()`와 `quack()` 외의 다른 부분은 잘 작동하고 있다. 즉, *오리의 행동*이 바뀌는 부분이다. 그렇다면 `fly()` 와 `quack()`같은 *오리의 행동*을 동적으로 세팅 할 수 있다면 아주 좋을 것이다
예를들어 MallardDuck 객체를 생성할 때에, 특정 fly 행동을 생성자 인자에 넣는 방법이 있겠다. 한 보 더 나아가, 오리의 행동과 관련된 `setter` 메소드를 추가하여 객체를 생성한 후에도 얼마든지 오리의 행동을 재설정 할 수 있다면 더 좋을 것이다.
이렇게 비지니스 로직을 구성한 다음, 두 번째 디자인 원칙에 따라 설계해보자.

> 디자인원칙 2.
구현이 아닌 인터페이스에 맞춰서 프로그래밍 한다.

각 행동의 큰 틀은 인터페이스 `FlyBehavior`, `QuackBehavior`로 표현하고, 구체적인 설명은 각 인터페이스를 상속받아 구현하도록 하자.

**인터페이스 FlyBehavior**
```java
interface FlyBehavior {
	fly()
 }
 
class FlyWithWings implements FlyBehavior {
	fly() { "날개로 훨훨 날다" } // 나는 모습을 구현
 }
 
class FlyNoWay implements FlyBehavior {
	fly() { "stay.." } // 날 수 없음
 }
```
**인터페이스 QuackBehavior**
```java
interface QuackBehavior {
	quack()
 }
  
class Quack implements QuackBehavior {
	quack() { "꽥꽥" } 
 }
 
class Squeak implements QuackBehavior {
	quack() { "삑삑" } 
 }

class MuteQuack implements QuackBehavior {
	quack() { "..." } // 아무 소리도 내지 않음 
 }
```

이런 식으로 디자인하면 다른 형식의 객체에서도 나는 행동과 꽥꽥 행동을 재사용 할 수 있다. 또한, 기존의 `Quack`, `Squeak` 같은 행동 클래스를 전혀 건드리지 않고도 새로운 `MuteQuack` 행동을 추가할 수 있다.
### 그런데, 왜 인터페이스로 구현해야 할까?

![](https://images.velog.io/images/hanna2100/post/9ca4eb27-b2ab-4064-8c9b-7a47bbe656b2/315DB03D-EE07-4CCC-BD92-E672A79B4FFC.jpeg)

꼭 인터페이스를 사용해야하는 이유가 있을까? 추상클래스를 상속받아도 똑같은 기능을 구현할 수 있지 않을까?

*인터페이스*라는 것은 꼭, 자바의 `interface` 구조를 지칭하는 것이 아니다. *인터페이스에 맞춰 프로그래밍한다* 라는 말은 즉, 어떤 상위 형식(super type)에 맞춤으로 인해 다형성을 활용한다는 것이다.
객체의 변수 타입을 지정할 때 상위 형식을 사용한다면, 실제 그 객체에 변수를 대입할 때 에는 어떤 하위 객체가 와도 된다.
예를 든다면, `Cake` 인터페이스에 `eat()`이라는 메소드가 있고, 이 인터페이스를 `CheeseCake` 클래스에서는 `eat() { "치즈맛이 난다" } `로 오버라이드, `StrawBerryCake` 클래스에서는 `eat() { "딸기맛이 난다" }`로 오버라이드했다고 하자. 아래와 같이 상위형식 `Cake`로 변수타입 선언 후, 실제로는 `CheeseCake` 객체를 대입한다면, `eat()` 메소드 호출시 `"치즈맛이 난다"`가 실행되게 된다. 만약 `StrawBerryCake` 객체였다면 똑같은 `eat()`메소드지만 `"딸기맛이 난다"`가 실행될 것이다. 그것이 다형성이다.

> `Cake cake = new CheeseCake();`  -> `cake.eat();`

